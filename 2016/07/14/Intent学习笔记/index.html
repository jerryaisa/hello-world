<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Intent笔记 | Jerry&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#Intent笔记Intent负责对应用中一次操作进行描述，描述内容包括动作以及动作所涉及的数据，Android中的Intent机制则根据此描述，找到对应的组件，将Intent传递给该被调用组件，完成对组件的一次调用。可见，在Intent中提供了组件互相调用的相关信息，实现了调用者与被调用者之间的解耦。
####Intent的应用场合，主要有以下三种

启动一个Activity
 Activity">
<meta property="og:type" content="article">
<meta property="og:title" content="Intent笔记">
<meta property="og:url" content="http://yoursite.com/2016/07/14/Intent学习笔记/index.html">
<meta property="og:site_name" content="Jerry's blog">
<meta property="og:description" content="#Intent笔记Intent负责对应用中一次操作进行描述，描述内容包括动作以及动作所涉及的数据，Android中的Intent机制则根据此描述，找到对应的组件，将Intent传递给该被调用组件，完成对组件的一次调用。可见，在Intent中提供了组件互相调用的相关信息，实现了调用者与被调用者之间的解耦。
####Intent的应用场合，主要有以下三种

启动一个Activity
 Activity">
<meta property="og:image" content="http://images.cnitblog.com/blog/430074/201303/30232228-7018010dc763474db67a0fad6b3e33c9.jpg">
<meta property="og:updated_time" content="2016-07-15T06:18:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Intent笔记">
<meta name="twitter:description" content="#Intent笔记Intent负责对应用中一次操作进行描述，描述内容包括动作以及动作所涉及的数据，Android中的Intent机制则根据此描述，找到对应的组件，将Intent传递给该被调用组件，完成对组件的一次调用。可见，在Intent中提供了组件互相调用的相关信息，实现了调用者与被调用者之间的解耦。
####Intent的应用场合，主要有以下三种

启动一个Activity
 Activity">
<meta name="twitter:image" content="http://images.cnitblog.com/blog/430074/201303/30232228-7018010dc763474db67a0fad6b3e33c9.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Jerry&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jerry&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Intent学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/14/Intent学习笔记/" class="article-date">
  <time datetime="2016-07-14T09:35:43.000Z" itemprop="datePublished">2016-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Intent笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Intent笔记<br>Intent负责对应用中一次操作进行描述，描述内容包括动作以及动作所涉及的数据，Android中的Intent机制则根据此描述，找到对应的组件，将Intent传递给该被调用组件，完成对组件的一次调用。<code>可见，在Intent中提供了组件互相调用的相关信息，实现了调用者与被调用者之间的解耦。</code></p>
<p>####Intent的应用场合，主要有以下三种</p>
<ol>
<li><p><strong>启动一个Activity</strong></p>
<p> Activity.<font color="#1db2cc">startActivity</font>(Intent intent);　//启动一个Activity</p>
<p> Activity.<font color="#1db2cc">startActivityForResult</font>(Intent intent, int requestCode);　//启动一个<code>带请求码的Activity</code>，当该Activity结束时将回调<code>原Activity</code>的onActivityResult()方法，并返回一个<code>结果码</code>。</p>
</li>
<li><p><strong>启动一个Service</strong></p>
<p> Context.<font color="#1db2cc">startService</font>(Intent service); 　//启动一个服务</p>
<p> Context.<font color="#1db2cc">bindService</font>(Intent service, ServiceConnection conn, int flags); 　//通过bindService</p>
</li>
</ol>
<ol>
<li><p><strong>启动一个Broadcast(广播)发送给broadcast receivers(广播接收器)</strong></p>
<pre><code>sendBroadcast(Intent intent); 
sendBroadcastAsUser(Intent intent, UserHandle user); 
//
sendStickyBroadcast(Intent intent); 
sendStickyBroadcastAsUser(Intent intent, UserHandle user); 
//
sendOrderedBroadcast(Intent intent, String receiverPermission); 
sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
BroadcastReceiver resultReceiver,Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
</code></pre></li>
</ol>
<p>####Intent属性设置</p>
<p>Intent的属性设置包括：<code>Action</code>（要执行的动作）、<code>Data</code>（执行动作所操作的数据）、<code>Type</code>（显式的指定Intent的数据类型）、<code>Category</code>（执行动作的附加信息）、<code>Component</code>（指定Intent目标组件的类名称）、<code>Extras</code>（其它所有附加信息的集合）</p>
<ol>
<li><p><strong>Action，也就是要执行的动作</strong><br><br> SDk中定义了一些标准的动作，包括</p>
<p> onstant(动作常量) | Target component(目标组件) | Action(意义)<br> ———— | ————- | ————<br> ACTION_CALL  | activity      | Initiate a phone call.(发起呼叫。)<br> ACTION_EDIT  | activity       | Display data for the user to edit.<br> ACTION_MAIN  | activity      | Start up as the initial activity of a task, with no data input and no returned output.<br> ACTION_SYNC  | activity      | Synchronize data on a server with data on the mobile device.(移动设备上的数据和服务器上数据同步。)<br> ACTION_BATTERY_LOW  | broadcast receiver      | A warning that the battery is low.(的警告电池电量低。)<br> ACTION_HEADSET_PLUG  | broadcast receiver      | A headset has been plugged into the device, or unplugged from it.(头戴式耳机已插入设备，或从中拔出。)<br> ACTION_SCREEN_ON  | broadcast receiver      | The screen has been turned on.(屏幕已打开。)<br> ACTION_TIMEZONE_CHANGED  | broadcast receiver      | The setting for the time zone has changed.(时区的设置发生了变化。)</p>
<p> 其中，ACTION_CALL表示调用拨打电话的应用；<code>ACTION_EDIT</code>表示调用编辑器；ACTION_SYNC表示同步数据。</p>
<p> 当然，也可以自定义动作（自定义的动作在使用时，需要加上包名作为前缀，如”com.example.project.SHOW_COLOR”），并可定义相应的Activity来处理我们的自定义动作。</p>
</li>
<li><p><strong>Data（动作所操作的数据）</strong><br><br> 在Intent中，Data使用指向数据的URI来表示。比如，在联系人应用中，指向<code>联系人列表</code>的URI是content://contacts/people/。对于不同的动作，其URI数据的类型是不同的（可以设置type属性指定特定类型数据），如ACTION_EDIT指定Data为文件URI，打电话为tel:URI，访问网络为http:URI，而由<code>content provider(内容提供商)</code>提供的数据则为content: URIs。</p>
</li>
<li><p><strong>type（数据类型）</strong><br><br> 对于不同的动作，其URI数据的类型是不同的。通常，Intent的数据类型能够根据其数据本身进行判定，但是通过设置这个属性，可以强制采用显式指定的类型。</p>
</li>
<li><p><strong>Category（类别）被执行动作的附加信息</strong><br><br> Category表示执行动作的附加信息。比如，当我们想要让所执行的动作被接收后，作为顶级应用出现，位于其他所有应用的最上层，可以使用附加信息LAUNCHER_CATEGORY来实现。<br><br> 还有其他的为: </p>
<p> Constant(常量) | Meaning(意义)<br> ———— | ————-<br> ALTERNATIVE<em>CATEGORY(有选择的</em>类别) | 表示当前的Intent是一系列的可选动作中的一个，这些动作可以在同一块数据上执行。<br> CATEGORY<em>BROWSABLE(类别</em>可浏览的) | The target activity can be safely invoked by the browser to display data referenced by a link — for example, an image or an e-mail message.<br><strong>翻译:</strong> (表示目标activity可以被浏览器通过一个链接安全的呼出，来显示数据，例如一张图片或者是一个email消息)<br> CATEGORY<em>GADGE(类别</em>机件,部分part) | The activity can be embedded inside of another activity that hosts gadgets.<br><strong>翻译:</strong> (activity可以被嵌入在另一个activity(<code>that hosts gadgets</code>)中)<br> CATEGORY_HOME | The activity displays the home screen, the first screen the user sees when the device is turned on or when the HOME key is pressed.<br><strong>翻译:</strong> (这个activity将被显示在主屏幕上，就是设备开启时或者home键按下时，用户可以看到的第一个界面)<br> CATEGORY<em>LAUNCHER(类别</em>发射台) | The activity can be the initial activity of a task and is listed in the top-level application launcher.<br><strong>翻译:</strong> (activity在Launcher中会作为顶级应用出现在有所有应用的最上层，launcher就是指安卓的桌面应用程序)<br> CATEGORY<em>PREFERENCE(类别</em>偏好) | The target activity is a preference panel.<br><strong>翻译:</strong> (目标activity是一个偏好面板)</p>
</li>
<li><p><strong>Component（组件, 指定Intent目标组件的类名称）</strong><br><br> Component用于指定Intent目标组件的类名称。通常，Android会根据Intent 中所包含的其它属性信息（比如Action、Data/Type、Category）进行查找，并找到一个与之匹配的目标组件。但是，如果我们设置了Component属性，明确的指定了Intent目标组件的类名称，那么上述查找过程将不需要执行。</p>
</li>
<li><p><strong>Extras（其它所有附加信息的集合）</strong><br><br> 使用extras可以为组件提供扩展信息，比如，如果要执行“发送电子邮件”这个动作，可以将电子邮件的标题、正文等保存在extras里，传给电子邮件发送组件。</p>
</li>
</ol>
<p>####Intent解析过程</p>
<ul>
<li><p>在使用Intent时，根据是否明确的指定Intent对象的接收者，而分为两种情况。一种是显式的Intent，即在构造Intent对象时就指定其接收者；另一种是隐式的Intent，即在构造Intent对象时，并不指定其接收者。</p>
</li>
<li><p>对于显式的Intent来说，Android不需要解析Intent，因为目标组件已经很明确。对于隐式的Intent来说，Android需要对其进行解析，通过解析，将Intent映射给可以处理该Intent的Activity、Service或Broadcast。        </p>
</li>
<li><p>Intent解析机制是通过查找注册在AndroidManifest.xml文件中的所有IntentFilter，以及IntentFilter所定义的Intent，找到最匹配的Intent。</p>
<p>  <strong>在解析过程中，Android通过判断Intent的Action、Type、Category这三个属性，从而找出最匹配的Intent，具体的判断方法如下：</strong></p>
<p>  1.如果Intent指明了Action，则目标组件IntentFilter的Action列表中就必须包含有这个Action，否则不能匹配；</p>
<p>  2.如果Intent没有提供Type，系统将从Data中得到数据类型。目标组件的数据类型列表中必须包含Intent的数据类型，否则不能匹配。</p>
<p>  3.如果Intent中的数据不是content: URI，而且Intent也没有明确指定它的Type，将根据Intent中数据的scheme （比如 http: 或者mailto:） 进行匹配。同理，Intent 的scheme必须出现在目标组件的scheme列表中，否则不能匹配。</p>
<p>  4.如果Intent指定了一个或多个Category，这些类别必须全部出现在目标组件的类别列表中，否则不能匹配。</p>
</li>
</ul>
<p>####Intent使用实例</p>
<ol>
<li><p>调用其他的应用, 通过Intent可以调用并启动别的应用程序，比如调用拨打电话的程序，便可以使用如下的方法来完成：</p>
<pre><code>/*
　　* Function :  调用拨打电话的程序
　　* Author   :  博客园-依旧淡然
　　*/
　　public void intentDemo_Call() {
　　    Intent intent_call = new Intent();                //创建一个意图
　　    intent_call.setAction(Intent.ACTION_CALL);        //设置意图为打电话
　　    intent_call.setData(Uri.parse(&quot;tel:110&quot;));        //设置电话号码
　　    startActivity(intent_call);                       //启动意图
　　}
</code></pre><p>我们其实还可以这样写<br></p>
<pre><code>public void intentDemo_Call() {  
        Intent intent_call = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:110&quot;)); //直接创建一个拨打110的意图
        startActivity(intent_call); 
}
</code></pre><p><code>Intent.ACTION_CALL</code>是直接拨打出去，有时候我们只是要呼出拨打电话界面，并输入我们准备拨出的号码，由用户决定是否拨打，那么就需要用到<code>Intent.ACTION_DIAL</code><br><br>如下这样写:<br></p>
<pre><code>Uri uri = Uri.parse(&quot;tel:0800000123&quot;);  
Intent it = new Intent(Intent.ACTION_DIAL, uri);  
startActivity(it);
</code></pre><p>当然了，因为这里使用到了打电话的功能，我们还需要在AndroidManifest.xml文件中，添加申请打电话的资源权限，具体实现方法如下</p>
<pre><code>&lt;!-- 打电话的权限 --&gt;
&lt;uses-permission 
　　　　　　android:name=&quot;android.permission.CALL_PHONE&quot;    /&gt;　　
　　　　　　
</code></pre></li>
<li><p>跳转到另一个Activity<br><br>通过使用Intent不仅可以调用别的应用程序，还可以实现应用程序内部之间Activity的跳转。比如如下的代码便实现了从MainActivity跳转到SecondaryActivity，并向SecondaryActivity中传递了两个数据name和age。</p>
<pre><code>/*
      * Function  :  跳转到SecondaryActivity 
      * Author    :  博客园-依旧淡然
      */
     public void intentDemo_GoToSecondaryActivity() {
         Intent intent_toSecondary = new Intent();                      //创建一个意图
         intent_toSecondary.setClass(this, SecondaryActivity.class);    //指定跳转到SecondaryActivity
         intent_toSecondary.putExtra(&quot;name&quot;, &quot;jack&quot;);                   //设置传递内容name
         intent_toSecondary.putExtra(&quot;age&quot;, 23);                        //设置传递内容age
         startActivity(intent_toSecondary);                             //启动意图
     }
</code></pre><p>那么，如何在SecondaryActivity中接收从MainActivity中传过来的内容（name、age）呢？下面的代码给出了一种实现方案。</p>
<pre><code>/*
      * Function  :  接收mainActivity中的intent_toSecondary
      * Author    :  博客园-依旧淡然
      */
     public void acceptIntent() {
         Intent intent_accept = getIntent();           //创建一个接收意图
         Bundle bundle = intent_accept.getExtras();    //创建Bundle对象，用于接收Intent数据
         String name = bundle.getString(&quot;name&quot;);       //获取Intent的内容name
         int age = bundle.getInt(&quot;age&quot;);               //获取Intent的内容age
     }
</code></pre></li>
<li><p>发送一个带回调方法的意图<br><br>有时，我们可能需要通过定义在MainActivity中的某一控件来启动SecondaryActivity，并且当SecondaryActivity结束时，返给MainActivity一个执行结果。<br><br>要实现上述的功能，只需要完成以下三步骤即可。<br><br>（1）在MainActivity中使用<code>startActivityForResult</code>向SecondaryActivity发送带请求码的意图，具体实现方法如下：</p>
<pre><code>/*
      * Function  :  向SecondaryActivity发送带请求码的意图
      * Author    :  博客园-依旧淡然
      */
     public void intentDemo_request() {
         Intent intent_request = new Intent();                      //创建一个意图
         intent_request.setClass(this, SecondaryActivity.class);    //指定跳转到SecondaryActivity
         startActivityForResult(intent_request, REQUEST_CODE);      //启动带请求码意图
     }
</code></pre><p>（2）在SecondaryActivity中接收intent_request，并向意图中填充要返给MainActivity的内容，最后还需要设置一个返回码。具体的实现方法如下：</p>
<pre><code>/*
      * Function  :  接收mainActivity中的intent_request并返回一个结果码
      * Author    :  博客园-依旧淡然 
      */
     public void acceptIntentAndReturn() {
         Intent intent = getIntent();                           //创建一个接收意图
         intent.putExtra(&quot;back&quot;, &quot;data of SecondaryActivity&quot;);  //设置意图的内容
         setResult(RESULT_OK, intent);                        //设置结果码
         finish();                                              //结束SecondaryActivity，并返回MainActivity
     }     
</code></pre><p>3）当结束SecondaryActivity时，程序将返回到MainActivity界面。此时，MainActivity中的onActivityResult()方法将被回调，而我们要做的就是实现该方法。在本示例中，该方法的具体实现方法如下：</p>
<pre><code>/*
      * Function  :  onActivityResult回调方法
      * Author    :  博客园-依旧淡然
      */
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         if(requestCode == REQUEST_CODE &amp;&amp; resultCode == SecondaryActivity.RESULT_OK) {
             Bundle bundle = data.getExtras();
             String str = bundle.getString(&quot;back&quot;);
             Toast.makeText(this, &quot;从SecondaryActivity的返回值为：&quot; + str, Toast.LENGTH_LONG).show();
         }
     } 
</code></pre><p>以上的代码，我们通过判断requestCode和resultCode便可以唯一的确定MainActivity中的调用者和SecondaryActivity中的被调用者，建立起了一一对应的关系。并且，我们通过Bundle对象获取了从SecondaryActivity中返回给MainActivity的内容，并通过Toast进行了输出，如图2所示。<br><br><img src="http://images.cnitblog.com/blog/430074/201303/30232228-7018010dc763474db67a0fad6b3e33c9.jpg" alt="image"><br><br>图2 从SecondaryActivity中返回的内容<br><br>由图2可见，从SecondaryActivity中返回的内容正是我们在SecondaryActivity中定义的字符串“data of SecondaryActivity”。</p>
</li>
</ol>
<p>####下面再给出一些其他系统自带功能的调用:<br>显示网页</p>
<pre><code>Uri uri = Uri.parse(&quot;http://google.com&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);
</code></pre><p>显示地图</p>
<pre><code>Uri uri = Uri.parse(&quot;geo:38.899533,-77.036476&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);   
startActivity(it);   
</code></pre><p>调用短信程序 </p>
<pre><code>Intent it = new Intent(Intent.ACTION_VIEW, uri);  
it.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);   
it.setType(&quot;vnd.android-dir/mms-sms&quot;);  
startActivity(it); 
</code></pre><p>传送消息</p>
<pre><code>Uri uri = Uri.parse(&quot;smsto://0800000123&quot;);  
Intent it = new Intent(Intent.ACTION_SENDTO, uri);  
it.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);  
startActivity(it); 
</code></pre><p>传送 MMS</p>
<pre><code>Uri uri = Uri.parse(&quot;content://media/external/images/media/23&quot;);  
Intent it = new Intent(Intent.ACTION_SEND);   
it.putExtra(&quot;sms_body&quot;, &quot;some text&quot;);   
it.putExtra(Intent.EXTRA_STREAM, uri);  
it.setType(&quot;image/png&quot;);   
startActivity(it); 
</code></pre><p>传送 Email</p>
<pre><code>Uri uri = Uri.parse(&quot;mailto:xxx@abc.com&quot;);  
Intent it = new Intent(Intent.ACTION_SENDTO, uri);  
startActivity(it); 
//
Intent it = new Intent(Intent.ACTION_SEND);  
it.putExtra(Intent.EXTRA_EMAIL, &quot;me@abc.com&quot;);  
it.putExtra(Intent.EXTRA_TEXT, &quot;The email body text&quot;);  
it.setType(&quot;text/plain&quot;);  
startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;)); 
//
Intent it=new Intent(Intent.ACTION_SEND);    
String[] tos={&quot;me@abc.com&quot;};    
String[] ccs={&quot;you@abc.com&quot;};    
it.putExtra(Intent.EXTRA_EMAIL, tos);    
it.putExtra(Intent.EXTRA_CC, ccs);    
it.putExtra(Intent.EXTRA_TEXT, &quot;The email body text&quot;);    
it.putExtra(Intent.EXTRA_SUBJECT, &quot;The email subject text&quot;);    
it.setType(&quot;message/rfc822&quot;);    
startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;));
</code></pre><p>传送附件</p>
<pre><code>Intent it = new Intent(Intent.ACTION_SEND);  
it.putExtra(Intent.EXTRA_SUBJECT, &quot;The email subject text&quot;);  
it.putExtra(Intent.EXTRA_STREAM, &quot;file:///sdcard/mysong.mp3&quot;);  
sendIntent.setType(&quot;audio/mp3&quot;);  
startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;));
</code></pre><p>播放多媒体</p>
<pre><code>Uri uri = Uri.parse(&quot;file:///sdcard/song.mp3&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
it.setType(&quot;audio/mp3&quot;);  
startActivity(it); 
//
Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, &quot;1&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);
</code></pre><p><br>————————————————————————————————————————-<br><br>Market 相关 寻找某个应用</p>
<pre><code>Uri uri = Uri.parse(&quot;market://search?q=pname:pkg_name&quot;); //pkg_name is the full package path for an application
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);  
</code></pre><p>显示某个应用的相关信息</p>
<pre><code>Uri uri = Uri.parse(&quot;market://details?id=app_id&quot;);
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it);  
//where app_id is the application ID, find the ID by clicking on your application on Market home page, and notice the ID from the address bar
</code></pre><p><strong>翻译:</strong>我们可以在应用市场中查找你要找的app，点击他，注意地址栏，就可以看到app id<br><br>————————————————————————————————————————-<br></p>
<p>Uninstall 应用程序</p>
<pre><code>Uri uri = Uri.fromParts(&quot;package&quot;, strPackageName, null); 
Intent it = new Intent(Intent.ACTION_DELETE, uri);   
startActivity(it);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/14/Intent学习笔记/" data-id="ciqndvakj0002uvbr0d9xgyv8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/14/Android基础总览/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android 基础技术难点总览</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/14/Intent学习笔记/">Intent笔记</a>
          </li>
        
          <li>
            <a href="/2016/07/14/Android基础总览/">Android 基础技术难点总览</a>
          </li>
        
          <li>
            <a href="/2016/07/12/Butter Knife学习笔记/">ButterKnife学习笔记</a>
          </li>
        
          <li>
            <a href="/2016/07/12/React_native读书笔记/">React Native 读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 wangchong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>