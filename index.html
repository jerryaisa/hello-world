<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jerry's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jerry's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jerry's blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Jerry's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Jerry's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/Intent学习笔记/" itemprop="url">
                  Intent笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-14T17:35:43+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Intent笔记<br>Intent负责对应用中一次操作进行描述，描述内容包括动作以及动作所涉及的数据，Android中的Intent机制则根据此描述，找到对应的组件，将Intent传递给该被调用组件，完成对组件的一次调用。<code>可见，在Intent中提供了组件互相调用的相关信息，实现了调用者与被调用者之间的解耦。</code></p>
<p>####Intent的应用场合，主要有以下三种</p>
<ol>
<li><p><strong>启动一个Activity</strong></p>
<p> Activity.<font color="#1db2cc">startActivity</font>(Intent intent);　//启动一个Activity</p>
<p> Activity.<font color="#1db2cc">startActivityForResult</font>(Intent intent, int requestCode);　//启动一个<code>带请求码的Activity</code>，当该Activity结束时将回调<code>原Activity</code>的onActivityResult()方法，并返回一个<code>结果码</code>。</p>
</li>
<li><p><strong>启动一个Service</strong></p>
<p> Context.<font color="#1db2cc">startService</font>(Intent service); 　//启动一个服务</p>
<p> Context.<font color="#1db2cc">bindService</font>(Intent service, ServiceConnection conn, int flags); 　//通过bindService</p>
</li>
</ol>
<ol>
<li><p><strong>启动一个Broadcast(广播)发送给broadcast receivers(广播接收器)</strong></p>
<pre><code>sendBroadcast(Intent intent); 
sendBroadcastAsUser(Intent intent, UserHandle user); 
//
sendStickyBroadcast(Intent intent); 
sendStickyBroadcastAsUser(Intent intent, UserHandle user); 
//
sendOrderedBroadcast(Intent intent, String receiverPermission); 
sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
BroadcastReceiver resultReceiver,Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
</code></pre></li>
</ol>
<p>####Intent属性设置</p>
<p>Intent的属性设置包括：<code>Action</code>（要执行的动作）、<code>Data</code>（执行动作所操作的数据）、<code>Type</code>（显式的指定Intent的数据类型）、<code>Category</code>（执行动作的附加信息）、<code>Component</code>（指定Intent目标组件的类名称）、<code>Extras</code>（其它所有附加信息的集合）</p>
<ol>
<li><p><strong>Action，也就是要执行的动作</strong><br><br> SDk中定义了一些标准的动作，包括</p>
<p> onstant(动作常量) | Target component(目标组件) | Action(意义)<br> ———— | ————- | ————<br> ACTION_CALL  | activity      | Initiate a phone call.(发起呼叫。)<br> ACTION_EDIT  | activity       | Display data for the user to edit.<br> ACTION_MAIN  | activity      | Start up as the initial activity of a task, with no data input and no returned output.<br> ACTION_SYNC  | activity      | Synchronize data on a server with data on the mobile device.(移动设备上的数据和服务器上数据同步。)<br> ACTION_BATTERY_LOW  | broadcast receiver      | A warning that the battery is low.(的警告电池电量低。)<br> ACTION_HEADSET_PLUG  | broadcast receiver      | A headset has been plugged into the device, or unplugged from it.(头戴式耳机已插入设备，或从中拔出。)<br> ACTION_SCREEN_ON  | broadcast receiver      | The screen has been turned on.(屏幕已打开。)<br> ACTION_TIMEZONE_CHANGED  | broadcast receiver      | The setting for the time zone has changed.(时区的设置发生了变化。)</p>
<p> 其中，ACTION_CALL表示调用拨打电话的应用；<code>ACTION_EDIT</code>表示调用编辑器；ACTION_SYNC表示同步数据。</p>
<p> 当然，也可以自定义动作（自定义的动作在使用时，需要加上包名作为前缀，如”com.example.project.SHOW_COLOR”），并可定义相应的Activity来处理我们的自定义动作。</p>
</li>
<li><p><strong>Data（动作所操作的数据）</strong><br><br> 在Intent中，Data使用指向数据的URI来表示。比如，在联系人应用中，指向<code>联系人列表</code>的URI是content://contacts/people/。对于不同的动作，其URI数据的类型是不同的（可以设置type属性指定特定类型数据），如ACTION_EDIT指定Data为文件URI，打电话为tel:URI，访问网络为http:URI，而由<code>content provider(内容提供商)</code>提供的数据则为content: URIs。</p>
</li>
<li><p><strong>type（数据类型）</strong><br><br> 对于不同的动作，其URI数据的类型是不同的。通常，Intent的数据类型能够根据其数据本身进行判定，但是通过设置这个属性，可以强制采用显式指定的类型。</p>
</li>
<li><p><strong>Category（类别）被执行动作的附加信息</strong><br><br> Category表示执行动作的附加信息。比如，当我们想要让所执行的动作被接收后，作为顶级应用出现，位于其他所有应用的最上层，可以使用附加信息LAUNCHER_CATEGORY来实现。<br><br> 还有其他的为: </p>
<p> Constant(常量) | Meaning(意义)<br> ———— | ————-<br> ALTERNATIVE<em>CATEGORY(有选择的</em>类别) | 表示当前的Intent是一系列的可选动作中的一个，这些动作可以在同一块数据上执行。<br> CATEGORY<em>BROWSABLE(类别</em>可浏览的) | The target activity can be safely invoked by the browser to display data referenced by a link — for example, an image or an e-mail message.<br><strong>翻译:</strong> (表示目标activity可以被浏览器通过一个链接安全的呼出，来显示数据，例如一张图片或者是一个email消息)<br> CATEGORY<em>GADGE(类别</em>机件,部分part) | The activity can be embedded inside of another activity that hosts gadgets.<br><strong>翻译:</strong> (activity可以被嵌入在另一个activity(<code>that hosts gadgets</code>)中)<br> CATEGORY_HOME | The activity displays the home screen, the first screen the user sees when the device is turned on or when the HOME key is pressed.<br><strong>翻译:</strong> (这个activity将被显示在主屏幕上，就是设备开启时或者home键按下时，用户可以看到的第一个界面)<br> CATEGORY<em>LAUNCHER(类别</em>发射台) | The activity can be the initial activity of a task and is listed in the top-level application launcher.<br><strong>翻译:</strong> (activity在Launcher中会作为顶级应用出现在有所有应用的最上层，launcher就是指安卓的桌面应用程序)<br> CATEGORY<em>PREFERENCE(类别</em>偏好) | The target activity is a preference panel.<br><strong>翻译:</strong> (目标activity是一个偏好面板)</p>
</li>
<li><p><strong>Component（组件, 指定Intent目标组件的类名称）</strong><br><br> Component用于指定Intent目标组件的类名称。通常，Android会根据Intent 中所包含的其它属性信息（比如Action、Data/Type、Category）进行查找，并找到一个与之匹配的目标组件。但是，如果我们设置了Component属性，明确的指定了Intent目标组件的类名称，那么上述查找过程将不需要执行。</p>
</li>
<li><p><strong>Extras（其它所有附加信息的集合）</strong><br><br> 使用extras可以为组件提供扩展信息，比如，如果要执行“发送电子邮件”这个动作，可以将电子邮件的标题、正文等保存在extras里，传给电子邮件发送组件。</p>
</li>
</ol>
<p>####Intent解析过程</p>
<ul>
<li><p>在使用Intent时，根据是否明确的指定Intent对象的接收者，而分为两种情况。一种是显式的Intent，即在构造Intent对象时就指定其接收者；另一种是隐式的Intent，即在构造Intent对象时，并不指定其接收者。</p>
</li>
<li><p>对于显式的Intent来说，Android不需要解析Intent，因为目标组件已经很明确。对于隐式的Intent来说，Android需要对其进行解析，通过解析，将Intent映射给可以处理该Intent的Activity、Service或Broadcast。        </p>
</li>
<li><p>Intent解析机制是通过查找注册在AndroidManifest.xml文件中的所有IntentFilter，以及IntentFilter所定义的Intent，找到最匹配的Intent。</p>
<p>  <strong>在解析过程中，Android通过判断Intent的Action、Type、Category这三个属性，从而找出最匹配的Intent，具体的判断方法如下：</strong></p>
<p>  1.如果Intent指明了Action，则目标组件IntentFilter的Action列表中就必须包含有这个Action，否则不能匹配；</p>
<p>  2.如果Intent没有提供Type，系统将从Data中得到数据类型。目标组件的数据类型列表中必须包含Intent的数据类型，否则不能匹配。</p>
<p>  3.如果Intent中的数据不是content: URI，而且Intent也没有明确指定它的Type，将根据Intent中数据的scheme （比如 http: 或者mailto:） 进行匹配。同理，Intent 的scheme必须出现在目标组件的scheme列表中，否则不能匹配。</p>
<p>  4.如果Intent指定了一个或多个Category，这些类别必须全部出现在目标组件的类别列表中，否则不能匹配。</p>
</li>
</ul>
<p>####Intent使用实例</p>
<ol>
<li><p>调用其他的应用, 通过Intent可以调用并启动别的应用程序，比如调用拨打电话的程序，便可以使用如下的方法来完成：</p>
<pre><code>/*
　　* Function :  调用拨打电话的程序
　　* Author   :  博客园-依旧淡然
　　*/
　　public void intentDemo_Call() {
　　    Intent intent_call = new Intent();                //创建一个意图
　　    intent_call.setAction(Intent.ACTION_CALL);        //设置意图为打电话
　　    intent_call.setData(Uri.parse(&quot;tel:110&quot;));        //设置电话号码
　　    startActivity(intent_call);                       //启动意图
　　}
</code></pre><p>我们其实还可以这样写<br></p>
<pre><code>public void intentDemo_Call() {  
        Intent intent_call = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:110&quot;)); //直接创建一个拨打110的意图
        startActivity(intent_call); 
}
</code></pre><p><code>Intent.ACTION_CALL</code>是直接拨打出去，有时候我们只是要呼出拨打电话界面，并输入我们准备拨出的号码，由用户决定是否拨打，那么就需要用到<code>Intent.ACTION_DIAL</code><br><br>如下这样写:<br></p>
<pre><code>Uri uri = Uri.parse(&quot;tel:0800000123&quot;);  
Intent it = new Intent(Intent.ACTION_DIAL, uri);  
startActivity(it);
</code></pre><p>当然了，因为这里使用到了打电话的功能，我们还需要在AndroidManifest.xml文件中，添加申请打电话的资源权限，具体实现方法如下</p>
<pre><code>&lt;!-- 打电话的权限 --&gt;
&lt;uses-permission 
　　　　　　android:name=&quot;android.permission.CALL_PHONE&quot;    /&gt;　　
　　　　　　
</code></pre></li>
<li><p>跳转到另一个Activity<br><br>通过使用Intent不仅可以调用别的应用程序，还可以实现应用程序内部之间Activity的跳转。比如如下的代码便实现了从MainActivity跳转到SecondaryActivity，并向SecondaryActivity中传递了两个数据name和age。</p>
<pre><code>/*
      * Function  :  跳转到SecondaryActivity 
      * Author    :  博客园-依旧淡然
      */
     public void intentDemo_GoToSecondaryActivity() {
         Intent intent_toSecondary = new Intent();                      //创建一个意图
         intent_toSecondary.setClass(this, SecondaryActivity.class);    //指定跳转到SecondaryActivity
         intent_toSecondary.putExtra(&quot;name&quot;, &quot;jack&quot;);                   //设置传递内容name
         intent_toSecondary.putExtra(&quot;age&quot;, 23);                        //设置传递内容age
         startActivity(intent_toSecondary);                             //启动意图
     }
</code></pre><p>那么，如何在SecondaryActivity中接收从MainActivity中传过来的内容（name、age）呢？下面的代码给出了一种实现方案。</p>
<pre><code>/*
      * Function  :  接收mainActivity中的intent_toSecondary
      * Author    :  博客园-依旧淡然
      */
     public void acceptIntent() {
         Intent intent_accept = getIntent();           //创建一个接收意图
         Bundle bundle = intent_accept.getExtras();    //创建Bundle对象，用于接收Intent数据
         String name = bundle.getString(&quot;name&quot;);       //获取Intent的内容name
         int age = bundle.getInt(&quot;age&quot;);               //获取Intent的内容age
     }
</code></pre></li>
<li><p>发送一个带回调方法的意图<br><br>有时，我们可能需要通过定义在MainActivity中的某一控件来启动SecondaryActivity，并且当SecondaryActivity结束时，返给MainActivity一个执行结果。<br><br>要实现上述的功能，只需要完成以下三步骤即可。<br><br>（1）在MainActivity中使用<code>startActivityForResult</code>向SecondaryActivity发送带请求码的意图，具体实现方法如下：</p>
<pre><code>/*
      * Function  :  向SecondaryActivity发送带请求码的意图
      * Author    :  博客园-依旧淡然
      */
     public void intentDemo_request() {
         Intent intent_request = new Intent();                      //创建一个意图
         intent_request.setClass(this, SecondaryActivity.class);    //指定跳转到SecondaryActivity
         startActivityForResult(intent_request, REQUEST_CODE);      //启动带请求码意图
     }
</code></pre><p>（2）在SecondaryActivity中接收intent_request，并向意图中填充要返给MainActivity的内容，最后还需要设置一个返回码。具体的实现方法如下：</p>
<pre><code>/*
      * Function  :  接收mainActivity中的intent_request并返回一个结果码
      * Author    :  博客园-依旧淡然 
      */
     public void acceptIntentAndReturn() {
         Intent intent = getIntent();                           //创建一个接收意图
         intent.putExtra(&quot;back&quot;, &quot;data of SecondaryActivity&quot;);  //设置意图的内容
         setResult(RESULT_OK, intent);                        //设置结果码
         finish();                                              //结束SecondaryActivity，并返回MainActivity
     }     
</code></pre><p>3）当结束SecondaryActivity时，程序将返回到MainActivity界面。此时，MainActivity中的onActivityResult()方法将被回调，而我们要做的就是实现该方法。在本示例中，该方法的具体实现方法如下：</p>
<pre><code>/*
      * Function  :  onActivityResult回调方法
      * Author    :  博客园-依旧淡然
      */
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         if(requestCode == REQUEST_CODE &amp;&amp; resultCode == SecondaryActivity.RESULT_OK) {
             Bundle bundle = data.getExtras();
             String str = bundle.getString(&quot;back&quot;);
             Toast.makeText(this, &quot;从SecondaryActivity的返回值为：&quot; + str, Toast.LENGTH_LONG).show();
         }
     } 
</code></pre><p>以上的代码，我们通过判断requestCode和resultCode便可以唯一的确定MainActivity中的调用者和SecondaryActivity中的被调用者，建立起了一一对应的关系。并且，我们通过Bundle对象获取了从SecondaryActivity中返回给MainActivity的内容，并通过Toast进行了输出，如图2所示。<br><br><img src="http://images.cnitblog.com/blog/430074/201303/30232228-7018010dc763474db67a0fad6b3e33c9.jpg" alt="image"><br><br>图2 从SecondaryActivity中返回的内容<br><br>由图2可见，从SecondaryActivity中返回的内容正是我们在SecondaryActivity中定义的字符串“data of SecondaryActivity”。</p>
</li>
</ol>
<p>####下面再给出一些其他系统自带功能的调用:<br>显示网页</p>
<pre><code>Uri uri = Uri.parse(&quot;http://google.com&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);
</code></pre><p>显示地图</p>
<pre><code>Uri uri = Uri.parse(&quot;geo:38.899533,-77.036476&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);   
startActivity(it);   
</code></pre><p>调用短信程序 </p>
<pre><code>Intent it = new Intent(Intent.ACTION_VIEW, uri);  
it.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);   
it.setType(&quot;vnd.android-dir/mms-sms&quot;);  
startActivity(it); 
</code></pre><p>传送消息</p>
<pre><code>Uri uri = Uri.parse(&quot;smsto://0800000123&quot;);  
Intent it = new Intent(Intent.ACTION_SENDTO, uri);  
it.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);  
startActivity(it); 
</code></pre><p>传送 MMS</p>
<pre><code>Uri uri = Uri.parse(&quot;content://media/external/images/media/23&quot;);  
Intent it = new Intent(Intent.ACTION_SEND);   
it.putExtra(&quot;sms_body&quot;, &quot;some text&quot;);   
it.putExtra(Intent.EXTRA_STREAM, uri);  
it.setType(&quot;image/png&quot;);   
startActivity(it); 
</code></pre><p>传送 Email</p>
<pre><code>Uri uri = Uri.parse(&quot;mailto:xxx@abc.com&quot;);  
Intent it = new Intent(Intent.ACTION_SENDTO, uri);  
startActivity(it); 
//
Intent it = new Intent(Intent.ACTION_SEND);  
it.putExtra(Intent.EXTRA_EMAIL, &quot;me@abc.com&quot;);  
it.putExtra(Intent.EXTRA_TEXT, &quot;The email body text&quot;);  
it.setType(&quot;text/plain&quot;);  
startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;)); 
//
Intent it=new Intent(Intent.ACTION_SEND);    
String[] tos={&quot;me@abc.com&quot;};    
String[] ccs={&quot;you@abc.com&quot;};    
it.putExtra(Intent.EXTRA_EMAIL, tos);    
it.putExtra(Intent.EXTRA_CC, ccs);    
it.putExtra(Intent.EXTRA_TEXT, &quot;The email body text&quot;);    
it.putExtra(Intent.EXTRA_SUBJECT, &quot;The email subject text&quot;);    
it.setType(&quot;message/rfc822&quot;);    
startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;));
</code></pre><p>传送附件</p>
<pre><code>Intent it = new Intent(Intent.ACTION_SEND);  
it.putExtra(Intent.EXTRA_SUBJECT, &quot;The email subject text&quot;);  
it.putExtra(Intent.EXTRA_STREAM, &quot;file:///sdcard/mysong.mp3&quot;);  
sendIntent.setType(&quot;audio/mp3&quot;);  
startActivity(Intent.createChooser(it, &quot;Choose Email Client&quot;));
</code></pre><p>播放多媒体</p>
<pre><code>Uri uri = Uri.parse(&quot;file:///sdcard/song.mp3&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
it.setType(&quot;audio/mp3&quot;);  
startActivity(it); 
//
Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, &quot;1&quot;);  
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);
</code></pre><p><br>————————————————————————————————————————-<br><br>Market 相关 寻找某个应用</p>
<pre><code>Uri uri = Uri.parse(&quot;market://search?q=pname:pkg_name&quot;); //pkg_name is the full package path for an application
Intent it = new Intent(Intent.ACTION_VIEW, uri);  
startActivity(it);  
</code></pre><p>显示某个应用的相关信息</p>
<pre><code>Uri uri = Uri.parse(&quot;market://details?id=app_id&quot;);
Intent it = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(it);  
//where app_id is the application ID, find the ID by clicking on your application on Market home page, and notice the ID from the address bar
</code></pre><p><strong>翻译:</strong>我们可以在应用市场中查找你要找的app，点击他，注意地址栏，就可以看到app id<br><br>————————————————————————————————————————-<br></p>
<p>Uninstall 应用程序</p>
<pre><code>Uri uri = Uri.fromParts(&quot;package&quot;, strPackageName, null); 
Intent it = new Intent(Intent.ACTION_DELETE, uri);   
startActivity(it);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/Android基础总览/" itemprop="url">
                  Android 基础技术难点总览
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-14T12:35:43+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Android 基础技术难点总览</p>
<p><a href="http://blog.csdn.net/Zengyangtech/article/details/6025676" target="_blank" rel="external">简要解释一下activity、 intent 、intent filter、service、Broadcast、BroadcaseReceiver</a></p>
<ol>
<li><p><strong>ServiceMananger</strong></p>
<p> 它是在init进程启动之后启动，从名字上就可以看出来它是<code>用来管理系统中的service</code></p>
<h6 id="Service-Manager存在的意义"><a href="#Service-Manager存在的意义" class="headerlink" title="Service Manager存在的意义"></a>Service Manager存在的意义</h6><ul>
<li>Service Manager能集中管理系统内的所有服务，它能被施加权限控制，并不是任何进程都能注册服务的。</li>
<li>Service Manager支持通过字符串名称来查找对应的Service。</li>
<li>由于各种原因的影响，Server进程可能生死无常。如果有了Service Manager做统一的管理，那么Client只要向Service Manager做查询，就能得到Server的最新信息。<br><br>参考文献:<br><br><a href="http://blog.csdn.net/xieqibao/article/details/6585143" target="_blank" rel="external">Android 之 ServiceManager与服务管理</a><br><br><a href="http://blog.csdn.net/hu3167343/article/details/38441119" target="_blank" rel="external">Android Binder机制浅析之ServiceManager</a><br><br><br></li>
</ul>
</li>
<li><p><strong>ActivityManager</strong></p>
<pre><code>//1. 返回用户最近使用过的应用程序信息集合。第一个参数是最大数量，第二个参数在API11前只有ActivityManager.RECENT_WITH_EXCLUDED。
List&lt;ActivityManager.RecentTaskInfo&gt;       getRecentTasks(int maxNum, int flags) 

//2. 返回设备上正在运行的程序的进程集合。
List&lt;ActivityManager.RunningAppProcessInfo&gt;           getRunningAppProcesses()

//3. 返回正在运行中的程序，参数为返回的最大个数，返回的顺序为  最近打开的程序，即优先返回最新使用的程序。返回值可能为空。
List&lt;ActivityManager.RunningTaskInfo&gt;        getRunningTasks(int maxNum)

//4. 杀死后台进程，参数为要被杀的程序的（主）包名。需要权限android.permission.KILL_BACKGROUND_PROCESSES。
void    killBackgroundProcesses (String packageName)

//5. 得到所有正在运行的service。
List&lt;ActivityManager.RunningServiceInfo&gt;           getRunningServices(int maxNum) 

//6. 现在这个方法等于方法4了，调用这个方法等于在调用方法4.
void    restartPackage (String packageName)
</code></pre><p> ActivityManager的一个运用实例就是，系统后台，可以罗列所有正在运行的程序，并杀死他们<br> <br>参考文献:<br> <br><a href="http://blog.csdn.net/liu149339750/article/details/8111462" target="_blank" rel="external">ActivityManager</a><br> <br><br></p>
</li>
<li><p><strong>packageManager</strong></p>
<p> 可以获取PackageInfo类，就是下面这张图最外面的红框，所有的pack信息都会被返回出来<br> <img src="http://images.cnitblog.com/blog/345073/201310/17160734-68ecdc58626449daa60361b0221cf1a6.png" alt="image"><br> <br>参考文献:<br> <br><a href="http://www.cnblogs.com/xingfuzzhd/p/3374504.html" target="_blank" rel="external">PackageManager使用</a><br> <br><a href="http://www.cnblogs.com/lee0oo0/archive/2012/08/08/2628458.html" target="_blank" rel="external">Android之使用PackageManager取得程序的包名、图标等</a><br> <br><br></p>
</li>
<li><p><strong>Binder</strong></p>
<p> 用于实现同进程或不同进程间，Activity和service之间的通信，本地又一个学习项目<code>BinderActivityAndService</code><br><br>位于/Users/wangchong/AwesomeProject下<br> <br><br></p>
</li>
<li><p><strong>IPC进程间通信</strong></p>
<p> 其实就是进程间通信的一个主要方式，4中用Binder使得Activity和service之间的通信，就是它的使用实例<br> <br>进程间通信还可以使用Intent，Intent还分显示和隐式<br> <br>显式–直接指定消息目的地，只适合同一进程内的不同组件之间通信 <code>new Intent(this,Target.class)</code><br> <br>隐式–AndroidMainifest.xml中注册，一般用于跨进程通信 <code>new Intent(String action)</code><br> <br>参考文献:<br> <br><a href="http://myqdroid.blog.51cto.com/2057579/394189/" target="_blank" rel="external">Android进程间通信–消息机制及IPC机制实现</a><br> <br><a href="http://www.cnblogs.com/freeliver54/archive/2012/06/13/2547739.html" target="_blank" rel="external">Android IPC进程通信——Messager方式</a> (这个其实就是第4点中提到的Binder)<br> <br><br></p>
</li>
<li><p><strong>Framework</strong></p>
<p> 说简单点，Framework具体的工作也就是为android应用开发的开发人员提供了一系列的服务和API的接口。是安卓底层提供的一些功能，有兴趣可以看看源码，了解安卓底层的实现方法<br> <br>参考文献:<br> <br><a href="http://blog.csdn.net/banketree/article/details/24718899" target="_blank" rel="external">Android Framework 记录之一</a><br> <br><a href="http://blog.csdn.net/column/details/android-framework.html" target="_blank" rel="external">Android Framework浅析专题</a> <code>(这个有空要细看，东西很多)</code><br> <br><br>    </p>
</li>
<li><strong>Hook</strong>(暂时不看，做个了解)<br> <br><br></li>
<li><p><strong>SystemService</strong></p>
<p> 和ServiceManager可以一起学，是在一起的，只是一个系统级的Service<br> <br>参考文献:<br> <br><a href="http://blog.csdn.net/androidmylove/article/details/9004892" target="_blank" rel="external">Android入门进阶教程(12)-SystemService详解</a><br> <br><br></p>
</li>
<li><p><strong>View 的渲染</strong></p>
<p> <br>参考文献:<br> <br><a href="http://www.open-open.com/lib/view/open1437961328925.html" target="_blank" rel="external">Android TextView预渲染研究</a><br> <br><a href="http://www.open-open.com/lib/view/open1429940596948.html" target="_blank" rel="external">Android性能优化之渲染篇</a><br> <br><a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇(原版地址)</a><br> <br><a href="http://www.cnblogs.com/xunbu7/p/4999038.html" target="_blank" rel="external">Android Shape渲染的使用（经典，学习研究不后悔）</a><br> <br><br></p>
</li>
<li><strong>Intent 是如何实现 Activity、Service 等之间的解耦合的？</strong>(有点无聊)<br><br><br></li>
<li><strong>单元测试会写了？Monkey 能跑多长时间？性能测试通过了？</strong>(有点无聊)<br><br><br></li>
<li><p><strong>ClassLoader 和 DexLoader 会玩了？</strong></p>
<p><br>参考文献:<br><br><a href="http://blog.csdn.net/com360/article/details/14125683" target="_blank" rel="external">Android中的类装载器DexClassLoader</a><br><br><a href="http://www.cnblogs.com/Lawson/archive/2012/07/31/2616623.html" target="_blank" rel="external">浅谈ClassLoader</a><br><br><a href="http://blog.chinaunix.net/uid-21227800-id-65885.html" target="_blank" rel="external">ClassLoader 详解及用途(写的不错) </a><br><br><br></p>
</li>
<li><p><strong>Context 是个啥你也知道了？</strong></p>
<p><br>参考文献:<br><br><a href="http://blog.csdn.net/qinjuning/article/details/7310620" target="_blank" rel="external">Android中Context详解 —- 你所不知道的Context</a><br><br><a href="http://blog.csdn.net/lmj623565791/article/details/40481055" target="_blank" rel="external">Android Context 上下文 你必须知道的一切</a><br><br><a href="http://www.cnblogs.com/android100/p/Android-Context.html" target="_blank" rel="external">Android源码分析-全面理解Context</a><br><br><br></p>
</li>
<li><p><strong>权限机制也弄清楚了？</strong></p>
<p><br>参考文献:<br><br><a href="http://blog.csdn.net/wxlinwzl/article/details/38395589" target="_blank" rel="external">Android的权限机制总结</a><br><br><a href="http://m.blog.csdn.net/article/details?id=51693586" target="_blank" rel="external">android权限机制，你真的了解么</a><br><br><a href="http://www.cnblogs.com/senix/archive/2013/01/15/2853733.html" target="_blank" rel="external">浅析Android权限机制（一）</a><br><br><a href="http://blog.csdn.net/andyhuabing/article/details/7464680" target="_blank" rel="external">Android 权限控制代码分析</a><br><br><br></p>
</li>
<li><p><strong>触屏事件的分发</strong></p>
<p><br>参考文献:<br><br><a href="http://www.cnblogs.com/linjzong/p/4191891.html" target="_blank" rel="external">Android:30分钟弄明白Touch事件分发机制</a><br><br><a href="http://blog.csdn.net/sunnyfans/article/details/8221505" target="_blank" rel="external">android触摸事件的分发和处理</a><br><br><a href="http://www.w2bc.com/article/117121" target="_blank" rel="external">一个demo让你彻底理解Android中触摸事件的分发</a><br><br><a href="http://blog.csdn.net/lingang1359/article/details/7046071" target="_blank" rel="external">Android 事件冒泡及捕获</a><br><br><a href="http://my.oschina.net/xesam/blog/71135" target="_blank" rel="external">android触屏事件流</a><br><br><br></p>
</li>
<li><p><strong>Handler 、Message 和 Looper 是怎么跑起来的</strong></p>
<p><br>参考文献:<br><br><a href="http://www.cnblogs.com/bastard/archive/2012/06/08/2541944.html" target="_blank" rel="external">Android中消息系统模型和Handler Looper</a><br><br><a href="http://blog.csdn.net/illusion_luna/article/details/8222657" target="_blank" rel="external">详解Handler和Looper的关系</a><br><br><a href="http://my.oschina.net/u/1024921/blog/121647" target="_blank" rel="external">Message、Handler、MessageQueue、Looper之间的关系</a><br><br><br></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/12/Butter Knife学习笔记/" itemprop="url">
                  ButterKnife学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-12T17:35:43+08:00" content="2016-07-12">
              2016-07-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#ButterKnife学习笔记<br><code>懒人必备</code></p>
<p>– 项目地址：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">https://github.com/JakeWharton/butterknife</a></p>
<p>我们可以根据github上这个项目自带的帮助，来完成初始配置}</p>
<ul>
<li><p>首先在项目级别的<code>build.gradle</code>增加如下的代码</p>
<p>   buildscript {</p>
<pre><code>repositories {
  mavenCentral()
 }
dependencies {
  classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
}
</code></pre><p>   }    </p>
</li>
<li><p>然后在模块级的<code>build.gradle</code>增加如下代码</p>
<p>   apply plugin: ‘android-apt’</p>
<p>   android {</p>
<pre><code>...
</code></pre><p>   }</p>
<p>   dependencies {</p>
<pre><code>compile &apos;com.jakewharton:butterknife:8.2.1&apos;
apt &apos;com.jakewharton:butterknife-compiler:8.2.1&apos;
</code></pre><p>   }</p>
</li>
</ul>
<p><strong>以上代码，都是从github copy的，使用时请从github直接复制，项目更新时，脚本可能有变动</strong></p>
<p>ButterKnife帮助，可以看官网，官网最全<br><code>http://jakewharton.github.io/butterknife/</code><br><br><br><br>                    </p>
<p>##现在已经可以使用ButterKnife了<br><code>代码大概是这样</code></p>
<pre><code>public class MainActivity extends AppCompatActivity {

    @BindView(R.id.text_veiw_tv1)
    TextView textVeiwTv1;
    @BindView(R.id.button_bt1)
    Button buttonBt1;
    @BindView(R.id.text_veiw_tv2)
    TextView textVeiwTv2;
    @BindView(R.id.button_bt2)
    Button buttonBt2;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);

        textVeiwTv1.setText(&quot;我草&quot;);

        textVeiwTv2.setText(&quot;牛逼啊&quot;);
    }

    @OnClick({R.id.text_veiw_tv1, R.id.button_bt1, R.id.text_veiw_tv2, R.id.button_bt2})
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.text_veiw_tv1:
                break;
            case R.id.button_bt1:
                break;
            case R.id.text_veiw_tv2:
                break;
            case R.id.button_bt2:
                break;
        }
    }
}
</code></pre><p>到这里我们虽然可以使用，但还不够懒，我们希望ButterKnife相关的代码，我们都不用手写，<code>机器就能搞定它！</code><br><br><br><br>   </p>
<p>##Android Studio 安装ButterKnife插件</p>
<ul>
<li><p>打开Plugins界面<br><img src="http://img.blog.csdn.net/20150811234046786" alt="打开Plugins界面"><br><br><br><br><img src="http://img.blog.csdn.net/20150608104715287 =900x" alt="image"></p>
</li>
<li><p><code>这里我们选择民间插件</code></p>
</li>
<li><p>搜索并将图形化生成代码的插件安装上<br><img src="http://img.blog.csdn.net/20150811234249201 =900x" alt="image"></p>
</li>
<li><p>我们可以像下面这样使用了<br><img src="https://github.com/avast/android-butterknife-zelezny/raw/master/img/zelezny_animated.gif" alt="image"></p>
</li>
</ul>
<p><br><br><br>   </p>
<p>##正式开始使用ButterKnife</p>
<p>####在activity中使用</p>
<ul>
<li><p>首先我们使用@BindView去绑定view id</p>
<pre><code>class ExampleActivity extends Activity {
  @BindView(R.id.title) TextView title;
  @BindView(R.id.subtitle) TextView subtitle;
  @BindView(R.id.footer) TextView footer;

  @Override public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.simple_activity);
    ButterKnife.bind(this);
    // TODO Use fields...
  }
}
</code></pre></li>
<li><p><code>ButterKnife.bind(this)</code>其实就是做了这些</p>
<pre><code>public void bind(ExampleActivity activity) {
  activity.subtitle = (android.widget.TextView) activity.findViewById(2130968578);
  activity.footer = (android.widget.TextView) activity.findViewById(2130968579);
  activity.title = (android.widget.TextView) activity.findViewById(2130968577);
}
</code></pre></li>
<li><p>资源绑定的方法</p>
<pre><code>class ExampleActivity extends Activity {
  @BindString(R.string.title) String title;
  @BindDrawable(R.drawable.graphic) Drawable graphic;
  @BindColor(R.color.red) int red; // int or ColorStateList field
  @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field
  // ...
}
</code></pre></li>
</ul>
<p>####如果不在activity中使用(Fragment或者Adapter)，你只需要告诉他view是那个就可以了</p>
<p>像这样<code>ButterKnife.bind(this, view);</code></p>
<ul>
<li><p>Fragment中的例子</p>
<pre><code>public class FancyFragment extends Fragment {
  @BindView(R.id.button1) Button button1;
  @BindView(R.id.button2) Button button2;

  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fancy_fragment, container, false);
    ButterKnife.bind(this, view);
    // TODO Use fields...
    return view;
  }
}
</code></pre></li>
<li><p>Adapter中的例子</p>
<pre><code>public class MyAdapter extends BaseAdapter {
  @Override public View getView(int position, View view, ViewGroup parent) {
    ViewHolder holder;
    if (view != null) {
      holder = (ViewHolder) view.getTag();
    } else {
      view = inflater.inflate(R.layout.whatever, parent, false);
      holder = new ViewHolder(view);
      view.setTag(holder);
    }

    holder.name.setText(&quot;John Doe&quot;);
    // etc...

    return view;
  }

  static class ViewHolder {
    @BindView(R.id.title) TextView name;
    @BindView(R.id.job_title) TextView jobTitle;

    public ViewHolder(View view) {
      ButterKnife.bind(this, view);
    }
  }
}
</code></pre></li>
<li><p>把多个view放入一个List中</p>
<pre><code>@BindViews({ R.id.first_name, R.id.middle_name, R.id.last_name })
List&lt;EditText&gt; nameViews;
</code></pre><p>apply方法允许队List中所有元素统一修改状态</p>
<pre><code>ButterKnife.apply(nameViews, DISABLE);
ButterKnife.apply(nameViews, ENABLED, false);
</code></pre><p>Action和Setter接口允许指定简单的行为。</p>
<pre><code>static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() {
  @Override public void apply(View view, int index) {
    view.setEnabled(false);
  }
};
static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() {
  @Override public void set(View view, Boolean value, int index) {
    view.setEnabled(value);
  }
};
</code></pre><p>android自己的属性也可以用apply去统一修改，像这样</p>
<pre><code>ButterKnife.apply(nameViews, View.ALPHA, 0.0f);
</code></pre><p>也可以在方法上，直接配置，把它设定为指定view的监听器(还可以重载，下面两个submit支持有参数或者无参数)</p>
<pre><code>@OnClick(R.id.submit)
public void submit(View view) {
  // TODO submit data to server...
}

@OnClick(R.id.submit)
public void submit() {
  // TODO submit data to server...
}
</code></pre><p>参数还可以传特定的类型(让button上的文字改变)</p>
<pre><code>@OnClick(R.id.submit)
public void sayHi(Button button) {
  button.setText(&quot;Hello!&quot;);
}
</code></pre><p>指定多个id的绑定</p>
<pre><code>@OnClick({ R.id.door1, R.id.door2, R.id.door3 })
public void pickDoor(DoorView door) {
  if (door.hasPrizeBehind()) {
    Toast.makeText(this, &quot;You win!&quot;, LENGTH_SHORT).show();
  } else {
    Toast.makeText(this, &quot;Try again&quot;, LENGTH_SHORT).show();
  }
}
</code></pre><p>自定义的view也可以通过不指定id，就绑定自己的onclick事件</p>
<pre><code>public class FancyButton extends Button {
  @OnClick
  public void onClick() {
      // 这里FancyButton连id都没有...
    // TODO do something!
  }
}
</code></pre></li>
<li><p>因为Fragments和activity的生命周期不同，所以建议在Fragments中使用Butter Knife需要在onDestroyView中释放</p>
<pre><code>public class FancyFragment extends Fragment {
  @BindView(R.id.button1) Button button1;
  @BindView(R.id.button2) Button button2;
  private Unbinder unbinder;

  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fancy_fragment, container, false);
    unbinder = ButterKnife.bind(this, view);
    // TODO Use fields...
    return view;
  }

  @Override public void onDestroyView() {
    super.onDestroyView();
    unbinder.unbind();
  }
}
</code></pre></li>
<li><p>默认情况下，@Bind和监听绑定，targetView是必须的，如果它不存在，就会报错，为了抑制这种情况，<code>鼓励使用一个可选的绑定</code>，增加@Nullable注释<code>字段</code>或@optional注释的<code>方法</code>，记住这是被鼓励的，你可以在任何地方都去注释! 如果targetView存在,则注入, 不存在,则什么事情都不做. <code>当布局被复用时,这个@Optional注解很有用.</code></p>
<pre><code>@Nullable annotation from Android&apos;s &quot;support-annotations&quot; library.

@Nullable @BindView(R.id.might_not_be_there) TextView mightNotBeThere;

@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() {
  // TODO ...
}
</code></pre></li>
<li><p>如果指定的view的监听器有多个回调，也可以用注释一一绑定，可以使用callback参数声明一个可替代的回调。</p>
<pre><code>@OnItemSelected(R.id.my_spinner)
void onItemSelected(int position) {
  // TODO ...
}

@OnItemSelected(value = R.id.my_spinner, callback = NOTHING_SELECTED)
void onNothingSelected() {
  // TODO ...
}
</code></pre><p>有一些View的listener是有多个回调方法的, spinner本来的回调</p>
<pre><code>mSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
    @Override
    public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) {
    }

    @Override
    public void onNothingSelected(AdapterView&lt;?&gt; parent) {
    }
});
</code></pre><p><code>看一个例子：</code><br><a href="https://github.com/mengdd/AndroidButterKnifeSample/blob/master/app/src/main/java/com/example/mengdd/butterknifesample/SpinnerActivity.java" target="_blank" rel="external">https://github.com/mengdd/AndroidButterKnifeSample/blob/master/app/src/main/java/com/example/mengdd/butterknifesample/SpinnerActivity.java</a><br><br><br><br></p>
</li>
<li><p>ButterKnife也支持这样findView，返回的是范型。所以前面不需要再(TextView)这样转化类型了</p>
<pre><code>View view = LayoutInflater.from(context).inflate(R.layout.thing, null);
TextView firstName = ButterKnife.findById(view, R.id.first_name);
TextView lastName = ButterKnife.findById(view, R.id.last_name);
ImageView photo = ButterKnife.findById(view, R.id.photo);
</code></pre></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/12/React_native读书笔记/" itemprop="url">
                  React Native 读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-12T12:35:43+08:00" content="2016-07-12">
              2016-07-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#React Native 读书笔记</p>
<ul>
<li><p><code>首先安装环境</code></p>
<p>   brew install node<br>   brew install watchman</p>
</li>
<li><p><code>安装react-native</code></p>
<p>   npm install -g react-native-cli</p>
</li>
<li><p><code>创建react-nactive项目</code></p>
<p>   react-native init AwesomeProject</p>
</li>
</ul>
<ul>
<li><p>用android studio 打开AwesomeProject文件夹下的<code>android文件夹</code>，这个文件夹才是安卓项目，直接打开AwesomeProject，无法在图形化界面启动debug</p>
</li>
<li><p>在android studio内的Terminal中输入adb devices，检查手机是否正常链接</p>
<p>   $ adb devices<br>   List of devices attached<br>   emulator-5554 offline   # Google模拟器<br>   14ed2fcc device         # 真实设备</p>
</li>
<li><p>cd .. 回到AwesomeProject目录，输入react-native run-android 项目启动</p>
<p>   cd ..<br>   react-native run-android</p>
</li>
</ul>
<p>#重点来了<br>这时候可能显示一个红色界面，不可用，按照一下步骤操作</p>
<ol>
<li><code>首先确保你的电脑和手机设备在同一个Wi-Fi环境下。</code></li>
<li>在设备上运行你的React Native应用。和打开其它App一样操作。</li>
<li>你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。</li>
<li>摇晃设备，或者运行adb shell input keyevent 82，可以打开开发者菜单。</li>
<li>点击进入Dev Settings。</li>
<li>点击Debug server host for device。</li>
<li>输入你电脑的IP地址和端口号（譬如10.0.1.1:8081）。在Mac上，你可以在系统设置/网络里找查询你的IP地址。在Windows上，打开命令提示符并输入ipconfig来查询你的IP地址。在Linux上你可以在终端中输入ifconfig来查询你的IP地址。</li>
<li>回到开发者菜单然后选择Reload JS。</li>
</ol>
<p>(Android 5.0及以上)使用adb reverse命令</p>
<ol>
<li>首先把你的设备通过USB数据线连接到电脑上，并开启USB调试（关于如何开启USB调试，参见上面的章节）。</li>
<li>运行adb reverse tcp:8081 tcp:8081</li>
<li>需要更多配置，你就可以使用Reload JS和其它的开发选项了。</li>
</ol>
<p>完成上面的设置后，你的手机可能仍显示红色屏幕，<code>这时候可能是js服务器没有启动</code>，你需要启动他，在android studio内的Terminal中输入:</p>
<pre><code>react-native start
</code></pre><p>现在可以跑了，我用android studio负责完成链接手机调试功能, 用Atom编辑JS文件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="wangchong" />
          <p class="site-author-name" itemprop="name">wangchong</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangchong</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
